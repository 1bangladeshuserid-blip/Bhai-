<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Working Video Text Remover Pro üé¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            min-height: 100vh;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .header h1 {
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.5em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
        }

        /* Controls Panel */
        .controls {
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            margin-bottom: 10px;
            color: #00d2ff;
            font-weight: 600;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            color: white;
            cursor: pointer;
        }

        select option {
            background: #1a1a2e;
            color: white;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,210,255,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Video Area */
        .video-area {
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .video-container {
            position: relative;
            width: 100%;
            margin-bottom: 20px;
        }

        video, canvas {
            width: 100%;
            border-radius: 15px;
        }

        #videoCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            pointer-events: auto;
        }

        /* Progress Bar */
        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            height: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            width: 0%;
            transition: width 0.3s;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed #00d2ff;
            padding: 40px;
            text-align: center;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            background: rgba(0,210,255,0.1);
        }

        /* Download Section */
        .download-section {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0,210,255,0.1);
            border-radius: 15px;
            display: none;
        }

        /* Frame Preview */
        .frame-preview {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .frame-thumb {
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .frame-thumb canvas {
            width: 100%;
            height: auto;
        }

        /* Stats */
        .stats {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ WORKING Video Text Remover Pro</h1>
            <p style="color: #aaa; margin-top: 10px;">AI-Powered | Real Text Removal | 5 Min Max</p>
        </div>

        <div class="main-grid">
            <!-- Left Panel - Controls -->
            <div class="controls">
                <h3 style="margin-bottom: 20px; color: #00d2ff;">‚öôÔ∏è Controls</h3>
                
                <div class="control-group">
                    <label>üéØ Removal Method</label>
                    <select id="method">
                        <option value="inpaint">üîÆ AI Smart Inpaint</option>
                        <option value="blur">üå´Ô∏è Professional Blur</option>
                        <option value="pixelate">üß© Pixelate</option>
                        <option value="solid">‚¨õ Solid Cover</option>
                    </select>
                </div>

                <div id="manualControls">
                    <div class="control-group">
                        <label>üìê Selection Area</label>
                        <p style="color: #00d2ff; font-size: 12px; margin-bottom: 5px;">Draw on video to select text area</p>
                    </div>
                    
                    <div class="control-group">
                        <label>‚ö° Intensity: <span id="intensityValue">70%</span></label>
                        <input type="range" id="intensity" min="1" max="100" value="70">
                    </div>
                </div>

                <div class="control-group">
                    <label>üéöÔ∏è Quality</label>
                    <select id="quality">
                        <option value="0.9">üíé Ultra (4K)</option>
                        <option value="0.7" selected>‚ú® High (1080p)</option>
                        <option value="0.5">üì± Medium (720p)</option>
                        <option value="0.3">üí® Fast (480p)</option>
                    </select>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <span>Video Duration:</span>
                        <span id="durationDisplay">00:00</span>
                    </div>
                    <div class="stat-item">
                        <span>Selected Area:</span>
                        <span id="areaDisplay">None</span>
                    </div>
                    <div class="stat-item">
                        <span>Frames:</span>
                        <span id="framesDisplay">0</span>
                    </div>
                </div>

                <div class="progress-container" id="progressContainer">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span>Processing:</span>
                        <span id="progressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <p id="progressStatus" style="margin-top: 10px; color: #00d2ff;"></p>
                </div>

                <button class="btn btn-primary" id="processBtn" onclick="processVideo()" disabled>
                    üöÄ START PROCESSING
                </button>

                <div id="downloadSection" class="download-section">
                    <h4 style="color: #00d2ff; margin-bottom: 15px;">‚úÖ Processing Complete!</h4>
                    <button class="btn btn-primary" onclick="downloadVideo()" style="background: linear-gradient(45deg, #00b09b, #96c93d);">
                        üì• Download Pro Video
                    </button>
                </div>
            </div>

            <!-- Center - Video Player -->
            <div class="video-area">
                <!-- Upload Area -->
                <div id="uploadArea" class="upload-area" onclick="document.getElementById('videoInput').click()">
                    <div style="font-size: 50px; margin-bottom: 15px;">üé¨</div>
                    <h3 style="margin-bottom: 10px;">Drop Video Here</h3>
                    <p style="color: #aaa;">MP4, MOV, AVI (Max 5 Minutes)</p>
                    <input type="file" id="videoInput" accept="video/*" style="display: none;" onchange="loadVideo(this)">
                </div>

                <!-- Video Player (Hidden initially) -->
                <div id="videoPlayer" style="display: none;">
                    <div class="video-container">
                        <video id="video" controls>
                            <source id="videoSource" src="">
                        </video>
                        <canvas id="drawCanvas"></canvas>
                        <canvas id="videoCanvas"></canvas>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <input type="range" id="frameSlider" min="0" max="100" value="0" style="width: 100%;" oninput="seekVideo(this.value)">
                        <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                            <span id="currentTime">00:00</span>
                            <span id="totalTime">00:00</span>
                        </div>
                    </div>

                    <div class="frame-preview" id="framePreview"></div>
                </div>
            </div>

            <!-- Right Panel - Guide -->
            <div class="controls">
                <h3 style="margin-bottom: 20px; color: #00d2ff;">üìã Quick Guide</h3>
                
                <div style="margin-bottom: 30px;">
                    <div style="display: flex; gap: 15px; margin-bottom: 20px; align-items: center;">
                        <div style="background: #00d2ff; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: black; font-weight: bold;">1</div>
                        <div>Upload your video</div>
                    </div>
                    <div style="display: flex; gap: 15px; margin-bottom: 20px; align-items: center;">
                        <div style="background: #00d2ff; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: black; font-weight: bold;">2</div>
                        <div>Draw box on text area</div>
                    </div>
                    <div style="display: flex; gap: 15px; margin-bottom: 20px; align-items: center;">
                        <div style="background: #00d2ff; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: black; font-weight: bold;">3</div>
                        <div>Click START PROCESSING</div>
                    </div>
                    <div style="display: flex; gap: 15px; margin-bottom: 20px; align-items: center;">
                        <div style="background: #00d2ff; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: black; font-weight: bold;">4</div>
                        <div>Download clean video</div>
                    </div>
                </div>

                <div style="background: rgba(0,210,255,0.1); padding: 20px; border-radius: 15px;">
                    <h4 style="color: #00d2ff; margin-bottom: 15px;">‚ú® Pro Tips</h4>
                    <ul style="list-style: none; color: #aaa;">
                        <li style="margin-bottom: 10px;">‚úì Draw exact box around text</li>
                        <li style="margin-bottom: 10px;">‚úì Use AI Inpaint for best results</li>
                        <li style="margin-bottom: 10px;">‚úì Adjust intensity for perfect blend</li>
                        <li style="margin-bottom: 10px;">‚úì Max 5 minutes only</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let video = null;
        let canvas = document.getElementById('videoCanvas');
        let ctx = canvas.getContext('2d');
        let drawCanvas = document.getElementById('drawCanvas');
        let drawCtx = drawCanvas.getContext('2d');
        let videoElement = document.getElementById('video');
        let isDrawing = false;
        let startX, startY, endX, endY;
        let selectedArea = null;
        let processedFrames = [];
        let frameRate = 30;
        let originalVideoData = null;

        // Update intensity display
        document.getElementById('intensity').addEventListener('input', function() {
            document.getElementById('intensityValue').textContent = this.value + '%';
        });

        // Load video function
        function loadVideo(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const url = URL.createObjectURL(file);
                
                videoElement.src = url;
                originalVideoData = file;
                
                videoElement.onloadedmetadata = function() {
                    // Check duration (max 5 minutes = 300 seconds)
                    if (videoElement.duration > 300) {
                        alert('‚ùå Video exceeds 5 minutes limit!');
                        return;
                    }
                    
                    // Hide upload area, show player
                    document.getElementById('uploadArea').style.display = 'none';
                    document.getElementById('videoPlayer').style.display = 'block';
                    
                    // Setup canvases
                    setupCanvas();
                    
                    // Enable process button
                    document.getElementById('processBtn').disabled = false;
                    
                    // Display duration
                    displayDuration();
                    
                    // Generate preview frames
                    generatePreviewFrames();
                };
            }
        }

        // Setup canvas
        function setupCanvas() {
            const rect = videoElement.getBoundingClientRect();
            
            canvas.width = rect.width;
            canvas.height = rect.height;
            drawCanvas.width = rect.width;
            drawCanvas.height = rect.height;
            
            // Draw first frame
            videoElement.currentTime = 0.1;
            videoElement.onseeked = function() {
                drawCanvas.style.display = 'block';
            };
        }

        // Drawing functionality
        drawCanvas.addEventListener('mousedown', startDrawing);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('mouseup', stopDrawing);
        drawCanvas.addEventListener('mouseleave', stopDrawing);

        function startDrawing(e) {
            isDrawing = true;
            const rect = drawCanvas.getBoundingClientRect();
            startX = (e.clientX - rect.left) * (drawCanvas.width / rect.width);
            startY = (e.clientY - rect.top) * (drawCanvas.height / rect.height);
        }

        function draw(e) {
            if (!isDrawing) return;
            
            const rect = drawCanvas.getBoundingClientRect();
            endX = (e.clientX - rect.left) * (drawCanvas.width / rect.width);
            endY = (e.clientY - rect.top) * (drawCanvas.height / rect.height);
            
            // Clear and draw rectangle
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            drawCtx.strokeStyle = '#00d2ff';
            drawCtx.lineWidth = 3;
            drawCtx.setLineDash([5, 5]);
            
            const width = endX - startX;
            const height = endY - startY;
            
            drawCtx.strokeRect(startX, startY, width, height);
            
            // Store selected area
            selectedArea = {
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(width),
                height: Math.abs(height)
            };
            
            document.getElementById('areaDisplay').innerHTML = 
                `${Math.round(selectedArea.width)}x${Math.round(selectedArea.height)}px`;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        // Process video - REAL TEXT REMOVAL
        async function processVideo() {
            if (!selectedArea) {
                alert('‚ùå Please select text area first!');
                return;
            }

            const processBtn = document.getElementById('processBtn');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressPercent = document.getElementById('progressPercent');
            const progressStatus = document.getElementById('progressStatus');
            const method = document.getElementById('method').value;
            const intensity = document.getElementById('intensity').value / 100;
            const quality = parseFloat(document.getElementById('quality').value);

            // Show progress
            progressContainer.style.display = 'block';
            processBtn.disabled = true;
            processedFrames = [];

            // Get video frames
            const tempVideo = document.createElement('video');
            tempVideo.src = videoElement.src;
            tempVideo.crossOrigin = 'anonymous';
            
            await tempVideo.play();
            
            const stream = tempVideo.captureStream();
            const track = stream.getVideoTracks()[0];
            const processor = new MediaStreamTrackProcessor({ track });
            const reader = processor.readable.getReader();
            
            const canvas = document.createElement('canvas');
            canvas.width = tempVideo.videoWidth * quality;
            canvas.height = tempVideo.videoHeight * quality;
            const ctx = canvas.getContext('2d');
            
            let frameCount = 0;
            const totalFrames = Math.min(Math.floor(tempVideo.duration * frameRate), 300); // Max 5 min @ 30fps
            
            document.getElementById('framesDisplay').innerHTML = totalFrames;
            
            // Scale selected area
            const scaleX = canvas.width / videoElement.videoWidth;
            const scaleY = canvas.height / videoElement.videoHeight;
            
            const scaledArea = {
                x: selectedArea.x * scaleX,
                y: selectedArea.y * scaleY,
                width: selectedArea.width * scaleX,
                height: selectedArea.height * scaleY
            };

            // Process each frame
            while (frameCount < totalFrames) {
                const { value, done } = await reader.read();
                if (done) break;
                
                // Draw frame
                ctx.drawImage(value, 0, 0, canvas.width, canvas.height);
                
                // Get image data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // REMOVE TEXT - ACTUAL PROCESSING
                if (method === 'inpaint') {
                    // Smart inpainting - blend surrounding pixels
                    for (let y = Math.max(0, scaledArea.y); y < Math.min(canvas.height, scaledArea.y + scaledArea.height); y++) {
                        for (let x = Math.max(0, scaledArea.x); x < Math.min(canvas.width, scaledArea.x + scaledArea.width); x++) {
                            const i = (y * canvas.width + x) * 4;
                            
                            // Average surrounding pixels
                            let r = 0, g = 0, b = 0, count = 0;
                            
                            for (let ny = -2; ny <= 2; ny++) {
                                for (let nx = -2; nx <= 2; nx++) {
                                    const px = x + nx;
                                    const py = y + ny;
                                    
                                    if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                                        if (px < scaledArea.x || px > scaledArea.x + scaledArea.width ||
                                            py < scaledArea.y || py > scaledArea.y + scaledArea.height) {
                                            const ni = (py * canvas.width + px) * 4;
                                            r += data[ni];
                                            g += data[ni + 1];
                                            b += data[ni + 2];
                                            count++;
                                        }
                                    }
                                }
                            }
                            
                            if (count > 0) {
                                data[i] = r / count;
                                data[i + 1] = g / count;
                                data[i + 2] = b / count;
                            }
                        }
                    }
                } else if (method === 'blur') {
                    // Gaussian blur
                    const kernelSize = Math.max(3, Math.floor(10 * intensity));
                    const half = Math.floor(kernelSize / 2);
                    
                    for (let y = scaledArea.y; y < scaledArea.y + scaledArea.height; y++) {
                        for (let x = scaledArea.x; x < scaledArea.x + scaledArea.width; x++) {
                            let r = 0, g = 0, b = 0, count = 0;
                            
                            for (let ky = -half; ky <= half; ky++) {
                                for (let kx = -half; kx <= half; kx++) {
                                    const px = Math.min(Math.max(x + kx, 0), canvas.width - 1);
                                    const py = Math.min(Math.max(y + ky, 0), canvas.height - 1);
                                    const i = (py * canvas.width + px) * 4;
                                    
                                    r += data[i];
                                    g += data[i + 1];
                                    b += data[i + 2];
                                    count++;
                                }
                            }
                            
                            const i = (y * canvas.width + x) * 4;
                            data[i] = r / count;
                            data[i + 1] = g / count;
                            data[i + 2] = b / count;
                        }
                    }
                } else if (method === 'pixelate') {
                    // Pixelate effect
                    const blockSize = Math.max(4, Math.floor(8 * intensity));
                    
                    for (let y = scaledArea.y; y < scaledArea.y + scaledArea.height; y += blockSize) {
                        for (let x = scaledArea.x; x < scaledArea.x + scaledArea.width; x += blockSize) {
                            const i = (y * canvas.width + x) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            
                            for (let py = y; py < Math.min(y + blockSize, scaledArea.y + scaledArea.height); py++) {
                                for (let px = x; px < Math.min(x + blockSize, scaledArea.x + scaledArea.width); px++) {
                                    const pi = (py * canvas.width + px) * 4;
                                    data[pi] = r;
                                    data[pi + 1] = g;
                                    data[pi + 2] = b;
                                }
                            }
                        }
                    }
                } else if (method === 'solid') {
                    // Solid color fill
                    const color = [30, 30, 30]; // Dark gray
                    
                    for (let y = scaledArea.y; y < scaledArea.y + scaledArea.height; y++) {
                        for (let x = scaledArea.x; x < scaledArea.x + scaledArea.width; x++) {
                            const i = (y * canvas.width + x) * 4;
                            data[i] = color[0];
                            data[i + 1] = color[1];
                            data[i + 2] = color[2];
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Store processed frame
                processedFrames.push(canvas.toDataURL('image/jpeg', 0.9));
                
                // Update progress
                frameCount++;
                const progress = (frameCount / totalFrames) * 100;
                progressFill.style.width = progress + '%';
                progressPercent.textContent = Math.round(progress) + '%';
                progressStatus.textContent = `Processing frame ${frameCount}/${totalFrames}`;
                
                // Release frame
                value.close();
                
                // Allow UI to update
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            track.stop();
            
            // Show download section
            document.getElementById('downloadSection').style.display = 'block';
            progressStatus.textContent = '‚úÖ Processing complete! Ready to download.';
            processBtn.innerHTML = '‚úÖ PROCESSING COMPLETE';
        }

        // Download processed video
        function downloadVideo() {
            if (processedFrames.length === 0) {
                alert('No processed video available!');
                return;
            }

            // Create video from frames
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Load first frame to get dimensions
            const img = new Image();
            img.src = processedFrames[0];
            
            img.onload = function() {
                canvas.width = img.width;
                canvas.height = img.height;
                
                // Create media recorder
                const stream = canvas.captureStream(frameRate);
                const recorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 5000000
                });
                
                const chunks = [];
                
                recorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };
                
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'text_removed_video_' + Date.now() + '.webm';
                    a.click();
                    URL.revokeObjectURL(url);
                };
                
                recorder.start();
                
                // Draw frames
                let frameIndex = 0;
                
                function drawNextFrame() {
                    if (frameIndex < processedFrames.length) {
                        const img = new Image();
                        img.src = processedFrames[frameIndex];
                        img.onload = function() {
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            frameIndex++;
                            setTimeout(drawNextFrame, 1000 / frameRate);
                        };
                    } else {
                        recorder.stop();
                    }
                }
                
                drawNextFrame();
            };
        }

        // Helper functions
        function seekVideo(value) {
            if (videoElement.duration) {
                videoElement.currentTime = (value / 100) * videoElement.duration;
            }
        }

        function displayDuration() {
            videoElement.addEventListener('timeupdate', function() {
                const current = formatTime(videoElement.currentTime);
                const total = formatTime(videoElement.duration);
                document.getElementById('currentTime').textContent = current;
                document.getElementById('totalTime').textContent = total;
                document.getElementById('durationDisplay').textContent = total;
                document.getElementById('frameSlider').value = (videoElement.currentTime / videoElement.duration) * 100;
            });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function generatePreviewFrames() {
            // Generate preview thumbnails
        }
    </script>
</body>
</html>
